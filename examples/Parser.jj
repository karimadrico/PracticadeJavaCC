// Mi primer parser en JavaCC - empezando desde cero
// Esto va a ser un mini-compilador para un lenguaje tipo COBOL

options {
  STATIC = false;           // Para poder crear varias instancias del parser
  CACHE_TOKENS = true;      // Mejora el rendimiento 
  OUTPUT_DIRECTORY = ".";   // Los archivos generados van en esta carpeta
}

PARSER_BEGIN(CobolCompiler)

import java.io.*;

public class CobolCompiler {

  // Variables para generar codigo intermedio
  java.util.List<String> codigo = new java.util.ArrayList<>();
  
  void emitir(String instruccion) {
    codigo.add(instruccion);
  }
  
  void mostrarCodigo() {
    System.out.println("=== Codigo intermedio generado ===");
    for (String inst : codigo) {
      System.out.println(inst);
    }
  }

  // Funcion principal - aqui empieza todo
  public static void main(String args[]) throws Exception {
    InputStream entrada = System.in;  // Por defecto lee del teclado
    
    // Si me pasan un archivo como parametro, leo de ahi
    if (args.length > 0) {
      entrada = new FileInputStream(args[0]);
    }
    
    // Creo el analizador y empiezo a procesar
    CobolCompiler miParser = new CobolCompiler(entrada);
    miParser.programa();
    System.out.println("Â¡El programa se analizo correctamente!");
  }
}

PARSER_END(CobolCompiler)

// Primero voy a definir los tokens basicos
TOKEN :
{
  // Numeros enteros - solo digitos
  <NUMERO: (["0"-"9"])+ >
| // Cadenas de texto entre comillas dobles
  <CADENA: "\"" (~["\"", "\n", "\r"])* "\"" >
| // Identificadores - nombres de variables (empiezan con letra)
  <IDENTIFICADOR: (["A"-"Z","a"-"z"]) (["A"-"Z","a"-"z","0"-"9"])* >
| // Puntuacion 
  <PUNTO: "." >
| <COMA: "," >
| <ABRE_PAREN: "(" >
| <CIERRA_PAREN: ")" >
}

TOKEN :
{
  <PROGRAMA: "PROGRAMA" >
| <INICIO: "INICIO" >
| <FIN: "FIN" >
| <MUESTRA: "MUESTRA" >
| <LEE: "LEE" >
| <MUEVE: "MUEVE" >
| <A: "A" >
| <SUMA: "SUMA" >
| <RESTA: "RESTA" >
| <SI: "SI" >
| <ENTONCES: "ENTONCES" >
| <FIN_SI: "FIN-SI" >
}

// Ignoro espacios, tabs, saltos de linea y comentarios
SKIP :
{
  " " | "\t" | "\n" | "\r"
| // Comentarios que empiezan con *> 
  <"*>" (~["\n", "\r"])* ("\n" | "\r")? >
| // Comentarios que empiezan con *|
  <"*|" (~["\n", "\r"])* ("\n" | "\r")? >
| // Comentarios en columna 7 (6 espacios + asterisco)
  <"      *" (~["\n", "\r"])* ("\n" | "\r")? >
}

// La gramatica - programa con multiples sentencias
void programa():
{}
{
  <PROGRAMA> <IDENTIFICADOR> <PUNTO>
  <INICIO>
  (sentencia())*
  <FIN> <PUNTO>
  <EOF>
  { 
    System.out.println("Programa completo reconocido");
    mostrarCodigo();
  }
}

// Una sentencia simple
void sentencia():
{}
{
  ( <MUESTRA> <CADENA> <PUNTO>
    {
      emitir("metecad " + token.image);
      emitir("print");
    }
  | <LEE> <IDENTIFICADOR> <PUNTO>
    {
      emitir("lee " + token.image);
    }
  | <MUEVE> <NUMERO> <A> <IDENTIFICADOR> <PUNTO>
    {
      emitir("mete " + getToken(1).image);
      emitir("asigna " + token.image);
    }
  | <SUMA> <NUMERO> <A> <IDENTIFICADOR> <PUNTO>
    {
      emitir("valord " + token.image);
      emitir("mete " + getToken(1).image);
      emitir("add");
      emitir("asigna " + token.image);
    }
  | <RESTA> <NUMERO> <A> <IDENTIFICADOR> <PUNTO>
    {
      emitir("valord " + token.image);
      emitir("mete " + getToken(1).image);
      emitir("sub");
      emitir("asigna " + token.image);
    }
  | <SI> <IDENTIFICADOR> <ENTONCES> (sentencia())* <FIN_SI> <PUNTO>
    {
      emitir("valord " + getToken(1).image);
      emitir("siciertovea LBLFIN");
      // Aqui irian las sentencias del SI
      emitir("LBLFIN:");
    }
  )
}
